<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Log in Apache Kafka | Jay Gandhi</title><meta name=keywords content="ApacheKafka,Kafka,messaging,distributed,log,throughput"><meta name=description content="This is first part of the series on Apache Kafka, a well known distributed messaging system. We will explore the log data structure, why it is important. It's not just about logging."><meta name=author content="Jay Gandhi"><link rel=canonical href=https://www.gandhijay.com/posts/apache-kafka-series-part-one/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.gandhijay.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gandhijay.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gandhijay.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gandhijay.com/apple-touch-icon.png><link rel=mask-icon href=https://www.gandhijay.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.gandhijay.com/posts/apache-kafka-series-part-one/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MJQYJ5FB0J"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MJQYJ5FB0J")}</script><meta property="og:url" content="https://www.gandhijay.com/posts/apache-kafka-series-part-one/"><meta property="og:site_name" content="Jay Gandhi"><meta property="og:title" content="Log in Apache Kafka"><meta property="og:description" content="This is first part of the series on Apache Kafka, a well known distributed messaging system. We will explore the log data structure, why it is important. It's not just about logging."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-07T02:39:21+05:30"><meta property="article:modified_time" content="2022-07-07T02:39:21+05:30"><meta property="article:tag" content="ApacheKafka"><meta property="article:tag" content="Kafka"><meta property="article:tag" content="Messaging"><meta property="article:tag" content="Distributed"><meta property="article:tag" content="Log"><meta property="article:tag" content="Throughput"><meta name=twitter:card content="summary"><meta name=twitter:title content="Log in Apache Kafka"><meta name=twitter:description content="This is first part of the series on Apache Kafka, a well known distributed messaging system. We will explore the log data structure, why it is important. It's not just about logging."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gandhijay.com/posts/"},{"@type":"ListItem","position":2,"name":"Log in Apache Kafka","item":"https://www.gandhijay.com/posts/apache-kafka-series-part-one/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Log in Apache Kafka","name":"Log in Apache Kafka","description":"This is first part of the series on Apache Kafka, a well known distributed messaging system. We will explore the log data structure, why it is important. It's not just about logging.","keywords":["ApacheKafka","Kafka","messaging","distributed","log","throughput"],"articleBody":"There are numerous articles discussing Apache Kafka[1], covering how companies utilize it, the problems it addresses, and how to create producers and consumers. Instead of diving into those topics right away (which I will certainly cover in future posts), let’s first explore its origins and what makes it faster than other messaging solutions.\nWhat is Log? The very first line of the Kafka paper[2 ] says\nLog processing has become a critical component of the data pipeline for consumer internet companies\nWhat is log data here that they are talking about? The first thing it came to mind was application logs which kinda look like this,\nThese Tomcat logs are humanly readable which simplest form of log that they are talking about which software produces.\nLog is a chronological record of actions/performance generated by system or human.\nHere, the system can be a simple web server, operating system, or software that generates syslogs[3 ], most database systems have transaction logs, etc. The system puts these logs into a single log file which we know as Logging. Some logs might be human-readable text files or some can be binary which the Database system provides.\nTransaction logs that are generated by the database is a chronological history of record of change made to the database. Those are separated from actual data files. In the MySQL world, it is known as ‘Binary Log’ and in Postgres, it is known as ‘Write-Ahead Log (WAL)’.\nThe logs here might be called ‘commit log’ or ‘journal’. From Jay Kreps’s blog on LinkedIn Engineering[4 ], Log is append-only, chronologically ordered records. Newer entries are added at end of the log.\nLog entries are pushed behind one another and reads proceed from right to left. Each record has been assigned a unique sequential log number. These are chronologically ordered, entries to the left record are older than their right side ones and the log number can be thought of as a timestamp. By describing ordering as a notion of time, Log entries are decoupled from the physical clocks. This is an essential property in distributed systems.[4 ]\nThere won’t be a single file where entries are recorded, the file will get too large or will run out of space. We’ll look into that in a future post.\nEvery software engineer/programmer is familiar with one or another definition of logging. We have seen one of the examples of the tomcat server above, the front-end developer using console.log() to write messages to the browser console. This are “Application logging” - unstructured error messages or trace info[4 ].\nLogs in Database We’ll look into Logs in Databases. Now and then server crashes, it might be a power failure at the data center or it might be a software issue. Stating Murphy’s law, ‘Anything that can go wrong will go wrong’ and it’s extended to ‘Anything that can go wrong will go wrong, and at the worst possible time’. The goal for the product should be to have minimum disruption if any of the services faulted.\nTherefore, Database systems that have durability, ensure changes made to the database that are successfully committed, will survive, in case of disruption. These are achieved by a commit log in the database system. Databases use the log to write information about these changes made to records before those changes are applied to the various data structure that DB maintains. Since the log is persisted instantly, it is used as an authoritative source to restore other persistent structures in event of failure.\nAs time went on, internet traffic increased, and having one database server to handle writes and reads impacted as well as availability. Having another database server or multiple servers that cater read operations, increases availability significantly. There are a lot of strategies are being used to replicate databases for read replicas or cross geo-replication. We will take the example of asynchronous replication, which is the most common and out-of-box configuration for many distributed systems.\nIn asynchronous replication, once the write operation completes, it immediately responds to the client. After that databases send the write operation’s transaction log to remote replicas to be in sync. Most databases have these kinds of log shipping protocols packaged which sends portions of the log to remote replicas.\nThe mechanism of using a transaction log for data transmission or processing is very much ideal for various data integrations or real-time messaging.\nLogs in Distributed System Will be added soon.\nNext My next post will be on comparison of other messaging queues like RabbitMQ, JMS etc. with Kafka.\nCheckout Messaging Queues - Apache Kafka Series - Part II Bibliography Apache Kafka, https://kafka.apache.org Jay Kreps, Neha Narkhede, and Jun Rao: “Kafka: A Distributed Messaging System for Log Processing ”, at 6th International Workshop on Networking Meets Databases (NetDB), June 2011. Syslog Link The Log: What every software engineer should know about real-time data’s unifying abstraction by Jay Kreps Link ","wordCount":"817","inLanguage":"en","datePublished":"2022-07-07T02:39:21+05:30","dateModified":"2022-07-07T02:39:21+05:30","author":{"@type":"Person","name":"Jay Gandhi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gandhijay.com/posts/apache-kafka-series-part-one/"},"publisher":{"@type":"Organization","name":"Jay Gandhi","logo":{"@type":"ImageObject","url":"https://www.gandhijay.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gandhijay.com/ accesskey=h title="Jay Gandhi (Alt + H)">Jay Gandhi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gandhijay.com/about/ title=About><span>About</span></a></li><li><a href=https://www.gandhijay.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://www.gandhijay.com/bookshelf/ title=Bookshelf><span>Bookshelf</span></a></li><li><a href=https://www.gandhijay.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.gandhijay.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.gandhijay.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Log in Apache Kafka</h1><div class=post-description>This is first part of the series on Apache Kafka, a well known distributed messaging system. We will explore the log data structure, why it is important. It's not just about logging.</div><div class=post-meta><span title='2022-07-07 02:39:21 +0530 IST'>July 7, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Jay Gandhi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#what-is-log>What is Log?</a></li><li><a href=#logs-in-database>Logs in Database</a></li><li><a href=#logs-in-distributed-system>Logs in Distributed System</a></li><li><a href=#next>Next</a></li><li><a href=#bibliography>Bibliography</a></li></ul></nav></div></details></div><div class=post-content><p>There are numerous articles discussing Apache Kafka[1], covering how companies utilize it, the problems it addresses, and how to create producers and consumers. Instead of diving into those topics right away (which I will certainly cover in future posts), let&rsquo;s first explore its origins and what makes it faster than other messaging solutions.</p><h2 id=what-is-log>What is Log?<a hidden class=anchor aria-hidden=true href=#what-is-log>#</a></h2><p>The very first line of the Kafka paper[<a href=#bibliography>2</a>
] says</p><blockquote><p>Log processing has become a critical component of the data pipeline for consumer internet companies</p></blockquote><p>What is log data here that they are talking about? The first thing it came to mind was application logs which kinda look like this,</p><p><img alt="Tomcat logs" loading=lazy src=/kafka/tomcat.jpg></p><p>These Tomcat logs are humanly readable which simplest form of log that they are talking about which software produces.</p><blockquote><p>Log is a chronological record of actions/performance generated by system or human.</p></blockquote><p>Here, the system can be a simple web server, operating system, or software that generates syslogs[<a href=#bibliography>3</a>
], most database systems have transaction logs, etc. The system puts these logs into a single log file which we know as Logging. Some logs might be human-readable text files or some can be binary which the Database system provides.</p><p>Transaction logs that are generated by the database is a chronological history of record of change made to the database. Those are separated from actual data files. In the MySQL world, it is known as &lsquo;Binary Log&rsquo; and in Postgres, it is known as &lsquo;Write-Ahead Log (WAL)&rsquo;.</p><p>The logs here might be called &lsquo;commit log&rsquo; or &lsquo;journal&rsquo;. From Jay Kreps&rsquo;s blog on LinkedIn Engineering[<a href=#bibliography>4</a>
], Log is append-only, chronologically ordered records. Newer entries are added at end of the log.</p><p><img alt="Log data structure" loading=lazy src=/kafka/log-ds-vis.jpg></p><p>Log entries are pushed behind one another and reads proceed from right to left. Each record has been assigned a unique sequential log number. These are chronologically ordered, entries to the left record are older than their right side ones and the log number can be thought of as a timestamp. By describing ordering as a notion of time, Log entries are decoupled from the physical clocks. This is an essential property in distributed systems.[<a href=#bibliography>4</a>
]</p><p>There won&rsquo;t be a single file where entries are recorded, the file will get too large or will run out of space. We&rsquo;ll look into that in a future post.</p><p>Every software engineer/programmer is familiar with one or another definition of logging. We have seen one of the examples of the tomcat server above, the front-end developer using <code>console.log()</code> to write messages to the browser console. This are &ldquo;Application logging&rdquo; - unstructured error messages or trace info[<a href=#bibliography>4</a>
].</p><h2 id=logs-in-database>Logs in Database<a hidden class=anchor aria-hidden=true href=#logs-in-database>#</a></h2><p>We&rsquo;ll look into Logs in Databases. Now and then server crashes, it might be a power failure at the data center or it might be a software issue. Stating Murphy&rsquo;s law, &lsquo;<strong>Anything that can go wrong will go wrong</strong>&rsquo; and it&rsquo;s extended to &lsquo;<strong>Anything that can go wrong will go wrong, and at the <em>worst possible time</em></strong>&rsquo;. The goal for the product should be to have minimum disruption if any of the services faulted.</p><p>Therefore, Database systems that have durability, ensure changes made to the database that are successfully committed, will survive, in case of disruption. These are achieved by a commit log in the database system. Databases use the log to write information about these changes made to records before those changes are applied to the various data structure that DB maintains. Since the log is persisted instantly, it is used as an authoritative source to restore other persistent structures in event of failure.</p><p>As time went on, internet traffic increased, and having one database server to handle writes and reads impacted as well as availability. Having another database server or multiple servers that cater read operations, increases availability significantly. There are a lot of strategies are being used to replicate databases for read replicas or cross geo-replication. We will take the example of asynchronous replication, which is the most common and out-of-box configuration for many distributed systems.</p><p>In asynchronous replication, once the write operation completes, it immediately responds to the client. After that databases send the write operation&rsquo;s transaction log to remote replicas to be in sync. Most databases have these kinds of log shipping protocols packaged which sends portions of the log to remote replicas.</p><p><img alt="Async Replication" loading=lazy src=/kafka/async-replication.jpg></p><p>The mechanism of using a transaction log for data transmission or processing is very much ideal for various data integrations or real-time messaging.</p><h2 id=logs-in-distributed-system>Logs in Distributed System<a hidden class=anchor aria-hidden=true href=#logs-in-distributed-system>#</a></h2><p>Will be added soon.</p><h2 id=next>Next<a hidden class=anchor aria-hidden=true href=#next>#</a></h2><p>My next post will be on comparison of other messaging queues like RabbitMQ, JMS etc. with Kafka.</p><p>Checkout <a href=/posts/apache-kafka-series-part-two>Messaging Queues - Apache Kafka Series - Part II</a></p><h2 id=bibliography>Bibliography<a hidden class=anchor aria-hidden=true href=#bibliography>#</a></h2><ol><li>Apache Kafka, <a href=https://kafka.apache.org target=_blank rel=noopener>https://kafka.apache.org</a></li><li>Jay Kreps, Neha Narkhede, and Jun Rao: “<a href=/kafka/kafka.pdf>Kafka: A Distributed Messaging System for Log Processing</a>
”, at 6th International Workshop on Networking Meets Databases (NetDB), June 2011.</li><li>Syslog <a href=https://en.wikipedia.org/wiki/Syslog target=_blank rel=noopener>Link</a></li><li>The Log: What every software engineer should know about real-time data&rsquo;s unifying abstraction by Jay Kreps <a href=https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying target=_blank rel=noopener>Link</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.gandhijay.com/tags/apachekafka/>ApacheKafka</a></li><li><a href=https://www.gandhijay.com/tags/kafka/>Kafka</a></li><li><a href=https://www.gandhijay.com/tags/messaging/>Messaging</a></li><li><a href=https://www.gandhijay.com/tags/distributed/>Distributed</a></li><li><a href=https://www.gandhijay.com/tags/log/>Log</a></li><li><a href=https://www.gandhijay.com/tags/throughput/>Throughput</a></li></ul><nav class=paginav><a class=prev href=https://www.gandhijay.com/posts/write-amplification-versus-read-perspiration/><span class=title>« Prev</span><br><span>Notes on Write Amplification versus Read Perspiration</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.gandhijay.com/>Jay Gandhi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>