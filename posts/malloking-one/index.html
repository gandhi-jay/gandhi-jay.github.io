<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a Simple Memory Allocator Using sbrk in C (Malloking Pt. 1) | Jay Gandhi</title><meta name=keywords content="malloc,memory,free,brk,sbrk,C,memory management,systems programming"><meta name=description content="A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C using the sbrk system call."><meta name=author content="Jay Gandhi"><link rel=canonical href=https://www.gandhijay.com/posts/malloking-one/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.gandhijay.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gandhijay.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gandhijay.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gandhijay.com/apple-touch-icon.png><link rel=mask-icon href=https://www.gandhijay.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.gandhijay.com/posts/malloking-one/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-R83NFY43QT"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R83NFY43QT")}</script><meta property="og:url" content="https://www.gandhijay.com/posts/malloking-one/"><meta property="og:site_name" content="Jay Gandhi"><meta property="og:title" content="Building a Simple Memory Allocator Using sbrk in C (Malloking Pt. 1)"><meta property="og:description" content="A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C using the sbrk system call."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-04-30T02:39:21+05:30"><meta property="article:modified_time" content="2025-04-30T02:39:21+05:30"><meta property="article:tag" content="Malloc"><meta property="article:tag" content="Memory"><meta property="article:tag" content="Free"><meta property="article:tag" content="Brk"><meta property="article:tag" content="Sbrk"><meta property="article:tag" content="C"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a Simple Memory Allocator Using sbrk in C (Malloking Pt. 1)"><meta name=twitter:description content="A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C using the sbrk system call."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gandhijay.com/posts/"},{"@type":"ListItem","position":2,"name":"Building a Simple Memory Allocator Using sbrk in C (Malloking Pt. 1)","item":"https://www.gandhijay.com/posts/malloking-one/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a Simple Memory Allocator Using sbrk in C (Malloking Pt. 1)","name":"Building a Simple Memory Allocator Using sbrk in C (Malloking Pt. 1)","description":"A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C using the sbrk system call.","keywords":["malloc","memory","free","brk","sbrk","C","memory management","systems programming"],"articleBody":"Introduction Before diving into this article, I recommend reviewing the relevant chapters from Computer Systems: A Programmer’s Perspective (CSAPP) , Chris Kanich’s lectures , and Operating Systems: Three Easy Pieces . These resources cover how memory allocation works and what happens under the hood when malloc is called. You’ll also want to understand the brk and sbrk system calls. Use any LLM if you’d like help parsing this material. this post is not a substitute for those references.\nGoals of this two part series Implement a simple memory allocator using only brk/sbrk Add a free list with a first-fit strategy using a linked list Improve allocation efficiency and reduce fragmentation Support block splitting and reuse Subscribe for free to receive updates when I add new article .\nImplementing simple allocator using brk/sbrk. Whole code can be found at the end of the post.\nMalloc and brk/sbrk At a high level, malloc is a function that takes a size in bytes and returns a void* pointing to the beginning of a block of memory. When it comes time to release that memory using free, you only need to pass the starting address of the block—the same pointer returned by malloc. This simplicity on the surface hides a key detail: your custom memory allocator must internally track each allocation to properly handle free operations.\nWithout this internal bookkeeping, there’s no way to verify whether the pointer being freed is valid, has already been freed, or was never allocated in the first place. As part of a robust implementation, your free function should detect such issues and raise appropriate errors to prevent undefined behavior or memory corruption.\nIt’s also important to understand that malloc and free are not system calls—they’re part of the C standard library. On most systems, they’re implemented in the GNU C Library (glibc). However, alternative memory allocators exist that offer improved performance or memory usage for specific workloads. Two well-known examples are jemalloc and tcmalloc, which are used in high-performance applications like databases and web servers.\nAllocator Structure Below is defined a Block struct to track each allocated or free memory chunk:\ntypedef struct block { size_t size; // how much memory the user asked for struct block* next; // pointer to the next block int free; // flag indicating if the block is free or used } Block; #define BLOCK_SIZE sizeof(Block); Block * free_list = NULL; malloc \u0026 free free is straight forward. It retrives the block metadata by subtracting the metadata size from the ptr. Why subtracting?\nWe are assuming block will be like as below, hence to get the actual block we need to subtract the metadata from given ptr.\n+------------------------+-------------------+ | Metadata | User Memory | | (struct Block) | (return ptr) | | | | | size | next | free bit | \u003c--- malloc ptr | +------------------------+-------------------+ # void *ptr = malloc(100); +-------------+---------------------+ | Metadata | 100 bytes | +-------------+---------------------+ ↑ ptr void free(void *ptr) { if (!ptr) return; // Should ideally raise an error but we are writing error-free code so... Block *block = (Block *)ptr - 1; block-\u003efree = 1; } Now malloc, Below are responsibilities it should do,\nFor best memory alignment, asked memory size should be converted to multiple of 8. Go through the available block for first fit. Whatever size of the block is found we’ll occupy. If not found, ask OS for more heap allocation using sbrk and get the new block and return the address after metadata is assgined. Before going into malloc, there is a concern, Malloc will be slow. It searches through the whole list, It should only check the blocks which are free. avoiding checking all the blocks linearly. for this to accomodate we need to do some change to the block and do some small bookkeeping in free. We’ll just remove free flag from block struct.\ntypedef struct block { size_t size; // how much memory the user asked for struct block* next; // pointer to the next block } Block; void free(void *ptr) { if (!ptr) return; // Silently return, not failing not. It should fail. Block *block = (Block *)ptr - 1; // Add block to the beginning of the list. block-\u003enext = free_list; free_list = block; } Now malloc,\nvoid *malloc(size_t size) { // Adds 7 to a number to get nearer to the post multiplicative of 8. and anding with ~7 just removes the any last 3 set bits // e.g. size is 55, 55 + 7 = 62. 62 (111110) \u0026 ~7 (111000) =\u003e 56 (111000) size = (size + 7) \u0026 ~7; // Align to 8 bytes. Block* prev = NULL; // Time to show your Leetcode skill. Block* current = free_list; while(current) { if (size \u003c= current-\u003esize) { // found. remove from the list // its in middle of the list if (prev) prev-\u003enext = current-\u003enext; else // First block itself. free_list = current-\u003enext; } prev = current; current = current-\u003enext; } // No reusable block found. Ask OS for new memory. void *new_block = sbrk(size + BLOCK_SIZE); if (new_block == (void*) -1) return NULL; // sbrk failed. Block *block = (Block*)new_block; block-\u003esize = size; return (void*)(block + 1); } Limitations\nThis allocator is extremely minimal and has several limitations:\nNo coalescing of adjacent free blocks No splitting of large blocks (leads to fragmentation) No thread safety No proper error handling Still, this is a solid foundation and a fun. Who knows—your billion-dollar allocator could start here. (Just kidding. Don’t ship this to production. Please. (but you can though! (no, you should not (…)) ))\nNext let’s implement splitting of large blocks and coalesing of adjacent free blocks.\nExample code for this post here .\nNext part in this series will be Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2) ","wordCount":"969","inLanguage":"en","datePublished":"2025-04-30T02:39:21+05:30","dateModified":"2025-04-30T02:39:21+05:30","author":{"@type":"Person","name":"Jay Gandhi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gandhijay.com/posts/malloking-one/"},"publisher":{"@type":"Organization","name":"Jay Gandhi","logo":{"@type":"ImageObject","url":"https://www.gandhijay.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gandhijay.com/ accesskey=h title="Jay Gandhi (Alt + H)">Jay Gandhi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gandhijay.com/about/ title=About><span>About</span></a></li><li><a href=https://www.gandhijay.com/ai/ title="AI Days"><span>AI Days</span></a></li><li><a href=https://www.gandhijay.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://www.gandhijay.com/bookshelf/ title=Bookshelf><span>Bookshelf</span></a></li><li><a href=https://www.gandhijay.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.gandhijay.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.gandhijay.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Building a Simple Memory Allocator Using sbrk in C (Malloking Pt. 1)</h1><div class=post-description>A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C using the sbrk system call.</div><div class=post-meta><span title='2025-04-30 02:39:21 +0530 IST'>April 30, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Jay Gandhi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#goals-of-this-two-part-series>Goals of this two part series</a></li></ul></li><li><a href=#malloc-and-brksbrk>Malloc and <code>brk/sbrk</code></a></li><li><a href=#allocator-structure>Allocator Structure</a></li><li><a href=#malloc--free><code>malloc</code> & <code>free</code></a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Before diving into this article, I recommend reviewing the relevant chapters from <a href=https://amzn.to/3Fy5csJ target=_blank rel=noopener><em>Computer Systems: A Programmer&rsquo;s Perspective (CSAPP)</em></a>
, <a href=https://dub.gandhijay.com/csapp-chris-kanich target=_blank rel=noopener>Chris Kanich’s lectures</a>
, and <a href=https://amzn.to/4kEYXlS target=_blank rel=noopener><em>Operating Systems: Three Easy Pieces</em></a>
. These resources cover how memory allocation works and what happens under the hood when <code>malloc</code> is called. You&rsquo;ll also want to understand the <code>brk</code> and <code>sbrk</code> system calls. Use any LLM if you&rsquo;d like help parsing this material. this post is not a substitute for those references.</p><h3 id=goals-of-this-two-part-series>Goals of this two part series<a hidden class=anchor aria-hidden=true href=#goals-of-this-two-part-series>#</a></h3><ul><li>Implement a simple memory allocator using only <code>brk</code>/<code>sbrk</code></li><li>Add a free list with a first-fit strategy using a linked list</li><li>Improve allocation efficiency and reduce fragmentation<ul><li>Support block splitting and reuse</li></ul></li></ul><p><a href=https://link.gandhijay.com/substack-subscribe target=_blank rel=noopener>Subscribe for free to receive updates when I add new article</a>
.</p><p>Implementing simple allocator using brk/sbrk. Whole code can be found at the end of the post.</p><h2 id=malloc-and-brksbrk>Malloc and <code>brk/sbrk</code><a hidden class=anchor aria-hidden=true href=#malloc-and-brksbrk>#</a></h2><p>At a high level, <code>malloc</code> is a function that takes a size in bytes and returns a <code>void*</code> pointing to the beginning of a block of memory. When it comes time to release that memory using <code>free</code>, you only need to pass the starting address of the block—the same pointer returned by <code>malloc</code>. This simplicity on the surface hides a key detail: your custom memory allocator must internally track each allocation to properly handle free operations.</p><p>Without this internal bookkeeping, there’s no way to verify whether the pointer being freed is valid, has already been freed, or was never allocated in the first place. As part of a robust implementation, your free function should detect such issues and raise appropriate errors to prevent undefined behavior or memory corruption.</p><p>It’s also important to understand that <code>malloc</code> and <code>free</code> are not system calls—they’re part of the C standard library. On most systems, they’re implemented in the GNU C Library (glibc). However, alternative memory allocators exist that offer improved performance or memory usage for specific workloads. Two well-known examples are jemalloc and tcmalloc, which are used in high-performance applications like databases and web servers.</p><h2 id=allocator-structure>Allocator Structure<a hidden class=anchor aria-hidden=true href=#allocator-structure>#</a></h2><p>Below is defined a Block struct to track each allocated or free memory chunk:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> block {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size;            <span style=color:#75715e>// how much memory the user asked for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> block<span style=color:#f92672>*</span> next;     <span style=color:#75715e>// pointer to the next block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> free;               <span style=color:#75715e>// flag indicating if the block is free or used
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} Block;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define BLOCK_SIZE sizeof(Block);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>Block <span style=color:#f92672>*</span> free_list <span style=color:#f92672>=</span> NULL;
</span></span></code></pre></div><h2 id=malloc--free><code>malloc</code> & <code>free</code><a hidden class=anchor aria-hidden=true href=#malloc--free>#</a></h2><p><code>free</code> is straight forward. It retrives the block metadata by subtracting the metadata size from the ptr. Why subtracting?</p><p>We are assuming block will be like as below, hence to get the actual block we need to subtract the metadata from given ptr.</p><pre tabindex=0><code>+------------------------+-------------------+
|       Metadata         |   User Memory     |
| (struct Block)         |   (return ptr)    |
|                        |                   |
| size | next | free bit | &lt;--- malloc ptr   |
+------------------------+-------------------+


# void *ptr = malloc(100);

+-------------+---------------------+
|  Metadata   |    100 bytes        |
+-------------+---------------------+
              ↑
             ptr
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ptr)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;     <span style=color:#75715e>// Should ideally raise an error but we are writing error-free code so...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Block <span style=color:#f92672>*</span>block <span style=color:#f92672>=</span> (Block <span style=color:#f92672>*</span>)ptr <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    block<span style=color:#f92672>-&gt;</span>free <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now malloc, Below are responsibilities it should do,</p><ul><li>For best memory alignment, asked memory size should be converted to multiple of 8.</li><li>Go through the available block for first fit. Whatever size of the block is found we&rsquo;ll occupy.</li><li>If not found, ask OS for more heap allocation using sbrk and get the new block and return the address after metadata is assgined.</li></ul><p>Before going into malloc, there is a concern, Malloc will be slow. It searches through the whole list, It should only check the blocks which are free. avoiding checking all the blocks linearly. for this to accomodate we need to do some change to the block and do some small bookkeeping in <code>free</code>. We&rsquo;ll just remove <code>free</code> flag from block struct.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> block {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>size_t</span> size;            <span style=color:#75715e>// how much memory the user asked for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> block<span style=color:#f92672>*</span> next;     <span style=color:#75715e>// pointer to the next block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} Block;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ptr)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;     <span style=color:#75715e>// Silently return, not failing not. It should fail.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Block <span style=color:#f92672>*</span>block <span style=color:#f92672>=</span> (Block <span style=color:#f92672>*</span>)ptr <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add block to the beginning of the list.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    block<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> free_list;
</span></span><span style=display:flex><span>    free_list <span style=color:#f92672>=</span> block;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now malloc,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Adds 7 to a number to get nearer to the post multiplicative of 8. and anding with ~7 just removes the any last 3 set bits
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// e.g. size is 55, 55 + 7 = 62. 62 (111110) &amp; ~7 (111000) =&gt; 56 (111000)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> (size <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span><span style=color:#ae81ff>7</span>;     <span style=color:#75715e>// Align to 8 bytes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Block<span style=color:#f92672>*</span> prev <span style=color:#f92672>=</span> NULL;         <span style=color:#75715e>// Time to show your Leetcode skill.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Block<span style=color:#f92672>*</span> current <span style=color:#f92672>=</span> free_list;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(current)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (size <span style=color:#f92672>&lt;=</span> current<span style=color:#f92672>-&gt;</span>size)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// found. remove from the list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// its in middle of the list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (prev)
</span></span><span style=display:flex><span>                prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// First block itself.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                free_list <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// No reusable block found. Ask OS for new memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>new_block <span style=color:#f92672>=</span> <span style=color:#a6e22e>sbrk</span>(size <span style=color:#f92672>+</span> BLOCK_SIZE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (new_block <span style=color:#f92672>==</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>) <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> NULL; <span style=color:#75715e>// sbrk failed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Block <span style=color:#f92672>*</span>block <span style=color:#f92672>=</span> (Block<span style=color:#f92672>*</span>)new_block;
</span></span><span style=display:flex><span>    block<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)(block <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Limitations</p><p>This allocator is extremely minimal and has several limitations:</p><ul><li>No coalescing of adjacent free blocks</li><li>No splitting of large blocks (leads to fragmentation)</li><li>No thread safety</li><li>No proper error handling</li></ul><p>Still, this is a solid foundation and a fun. Who knows—your billion-dollar allocator could start here. (Just kidding. Don’t ship this to production. Please. (but you can though! (no, you should not (&mldr;)) ))</p><p>Next let&rsquo;s implement splitting of large blocks and coalesing of adjacent free blocks.</p><p>Example code for this post <a href=https://link.gandhijay.com/code-malloking-pt-1 target=_blank rel=noopener>here</a>
.</p><p>Next part in this series will be <a href=https://link.gandhijay.com/post-rd-malloking-two target=_blank rel=noopener>Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2)</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.gandhijay.com/tags/malloc/>Malloc</a></li><li><a href=https://www.gandhijay.com/tags/memory/>Memory</a></li><li><a href=https://www.gandhijay.com/tags/free/>Free</a></li><li><a href=https://www.gandhijay.com/tags/brk/>Brk</a></li><li><a href=https://www.gandhijay.com/tags/sbrk/>Sbrk</a></li><li><a href=https://www.gandhijay.com/tags/c/>C</a></li><li><a href=https://www.gandhijay.com/tags/memory-management/>Memory Management</a></li><li><a href=https://www.gandhijay.com/tags/systems-programming/>Systems Programming</a></li></ul><nav class=paginav><a class=prev href=https://www.gandhijay.com/posts/malloking-two/><span class=title>« Prev</span><br><span>Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2)</span>
</a><a class=next href=https://www.gandhijay.com/posts/control-flow/><span class=title>Next »</span><br><span>Flow of Control (Control Flow)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.gandhijay.com/>Jay Gandhi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>