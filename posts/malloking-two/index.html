<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2) | Jay Gandhi</title><meta name=keywords content="malloc,memory,free,brk,sbrk,C,memory management,systems programming"><meta name=description content="A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C"><meta name=author content="Jay Gandhi"><link rel=canonical href=https://www.gandhijay.com/posts/malloking-two/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://www.gandhijay.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.gandhijay.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.gandhijay.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.gandhijay.com/apple-touch-icon.png><link rel=mask-icon href=https://www.gandhijay.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.gandhijay.com/posts/malloking-two/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-MJQYJ5FB0J"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-MJQYJ5FB0J")}</script><meta property="og:url" content="https://www.gandhijay.com/posts/malloking-two/"><meta property="og:site_name" content="Jay Gandhi"><meta property="og:title" content="Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2)"><meta property="og:description" content="A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-15T11:03:12+05:30"><meta property="article:modified_time" content="2025-05-15T11:03:12+05:30"><meta property="article:tag" content="Malloc"><meta property="article:tag" content="Memory"><meta property="article:tag" content="Free"><meta property="article:tag" content="Brk"><meta property="article:tag" content="Sbrk"><meta property="article:tag" content="C"><meta name=twitter:card content="summary"><meta name=twitter:title content="Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2)"><meta name=twitter:description content="A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.gandhijay.com/posts/"},{"@type":"ListItem","position":2,"name":"Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2)","item":"https://www.gandhijay.com/posts/malloking-two/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2)","name":"Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2)","description":"A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C","keywords":["malloc","memory","free","brk","sbrk","C","memory management","systems programming"],"articleBody":"Introduction In previous post , We implemented basic allocator which can be used in production enviornment for very faster memory allocation queries and we took the first step towards your first billion $$$. It was perfect but lets add more code to turn your billion dollars into millions. Let’s change the strategy to improve fragmentation by adding more code (more code -\u003e more bugs -\u003e more loss). Hence no-code is the future. There are two types of fragmentation, internal fragmentation, if 100 bytes are being asked to allocate, malloc returns block which size is 104. 4 bytes extra. Keep asking 100 bytes, 100 times, you will get 400 bytes extra in total but spread across the blocks in 4 bytes chunk. External fragmentation is if variable sized blocks are requested but there are none of the free blocks are in asked size. We’ll go deeper in later..\nSplitting In previous post, we used to any block that would be larger than or equal size of the requested size. size \u003c= currernt-\u003esize. Now, We’ll check that if block can be split into two blocks. New blocks’ sizes will be size and current-\u003esize - size. To Split, block size should be larger than the usable size. Usable size is summation of block metadata (sizeof Block) and minimum block size (8). Therefore block should only be splited if its size is greater than (or equal to) summation of requested size, block metadata and minimum block size. If leftover space after splitting is less than the block metadata + minimum block size then its not worth splitting, it would create an unsusable fragment.\nLet’s visualize it. We have block size of 100 bytes.\n+------------------------------+ | Block Header | \u003c-- current (size = 100) +------------------------------+ | | | Free Memory | | (size = 100 bytes) | | | +------------------------------+ Now, requested size is 40 bytes, so we need minimum 40 + Block Size (16) + Minimum split size (8) = 64 bytes of the block for able to split without unusable fragment.\n+------------------------------+------------------------------+ | Block Header A | Block Header B | +------------------------------+------------------------------+ | Allocated to user (40 B) | Remaining free (44 B) | | | | +------------------------------+------------------------------+ Block A total size: 40 (user) + 16 (header) = 56 Block B total size: 44 (free) = 44 ≥ MIN_SPLIT_SIZE If block size would have been 50, it’s no use to split as it would create 10B of unusable fragment.\nPost split, new block should be added to the free list.\nIn code, we need to make changes as below in malloc,\n#define MINIMUM_SPLIT_SIZE 8 void *malloc(size_t size) { Block *prev = NULL; Block *current = free_list; size = (size + 7) \u0026 ~7; // Align to 8 bytes // Search free_list only (not all blocks) while (current) { if (current-\u003esize \u003e= size) { // Check eligibilty of splitting. if (current-\u003esize \u003e= (size + BLOCK_SIZE + MINIMUM_SPLIT_SIZE)) { // Current block size would be reduced to requested size. // new_block will be splited free block Block *new_block = (Block *)((char *)current + BLOCK_SIZE + size); new_block-\u003esize = current-\u003esize - size - BLOCK_SIZE; new_block-\u003enext = current-\u003enext; current-\u003esize = size; if (prev) { prev-\u003enext = new_block; } else { free_list = new_block; } } else { // Remove from free list if (prev) { prev-\u003enext = current-\u003enext; } else { free_list = current-\u003enext; } } return (void *)(current + 1); } prev = current; current = current-\u003enext; } ... } Address ordered free_list As we are splitting the blocks, we need to coalesce the block as well to create a big block that can be splitted if required or satisfy the request of the similar size. From previous post, calling free is adding the freed block to the free_list’s head as shown below,\n+---------+ +---------+ +---------+ +---------+ free_list --\u003e | Block A | --\u003e | Block D | --\u003e | Block B | --\u003e | Block C | --\u003e NULL +---------+ +---------+ +---------+ +---------+ From random list, it will be additional effort to sort the list based on their addresses and then run coalesce logic. We can improve free to add free block in address order (sorted by memory address) so we can coalesce the consucutive block into one free block.\nvoid free(void *ptr) { if (!ptr) return; // Silently return, not failing not. It should fail. Block *block = (Block *)ptr - 1; // ptr points to payload not the Block Metadata. // Insert at correct position in adddress order for coalescing. if (!free_list || block \u003c free_list) { // Free list is either empty or block is located // earlier in the memory than current head of free_list. block-\u003enext = free_list; free_list = block; } else { Block *curr = free_list; while (current-\u003enext \u0026\u0026 current-\u003enext \u003c block) { current = current-\u003enext; } block-\u003enext = current-\u003enext; current-\u003enext = block; } // Call Coalescing logic? coalescing_free_list() } free_list will remain sorted by memory address.\nCoalescing There’s an option to call coalescing logic after the block is placed at its address ordered place. Coalescing everytime there’s new free block on the list seems overly aggressive as same block might colesced and splitted repeatedly and not coalescing everytime we might end up not using the free block avaialble despite the availibility. In Glibc, there are multiple lists called bins. Bins categorize free memory chunks by size and optimize their reuse. There are fastbins, smallbins and largebins. Whether coalescing occurs immediately or is deferred depends on which bin the chunk is placed in.\nFastbins is for the smaller allocation and lazily coalesced where smallbins and largebins are for medium to large allocations and immediately coalesced on free.\nFor simplicity, we’ll do coalescing each time we free the block.\nvoid coalescing_free_list() { Block *curr = free_list; while (current \u0026\u0026 current-\u003enext) { // Char *, it moves N bytes instead of sizeof Block. Raw memory layout math!! // This byte address right after the current block ends which is where next adjacent block would begin. /** * +------------------+-----------------------------+ * | Block Metadata | Usable memory (size B) | * +------------------+-----------------------------+ * ^ current ^ current + BLOCK_SIZE ^ curr_end */ char *curr_end = (char *)current + BLOCK_SIZE + current-\u003esize; if (curr_end == curr-\u003enext) { // Adjacent: Let's merge current-\u003esize = current-\u003esize + BLOCK_SIZE + current-\u003enext-\u003esize; current-\u003enext = current-\u003enext-\u003enext; } else { current = current-\u003enext; } } } It’s the basics of how basic memory allocator works.\n","wordCount":"1065","inLanguage":"en","datePublished":"2025-05-15T11:03:12+05:30","dateModified":"2025-05-15T11:03:12+05:30","author":{"@type":"Person","name":"Jay Gandhi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.gandhijay.com/posts/malloking-two/"},"publisher":{"@type":"Organization","name":"Jay Gandhi","logo":{"@type":"ImageObject","url":"https://www.gandhijay.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.gandhijay.com/ accesskey=h title="Jay Gandhi (Alt + H)">Jay Gandhi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.gandhijay.com/about/ title=About><span>About</span></a></li><li><a href=https://www.gandhijay.com/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://www.gandhijay.com/bookshelf/ title=Bookshelf><span>Bookshelf</span></a></li><li><a href=https://www.gandhijay.com/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.gandhijay.com/>Home</a>&nbsp;»&nbsp;<a href=https://www.gandhijay.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Adding Splitting and Coalescing in Basic Allocator in C (Malloking Pt. 2)</h1><div class=post-description>A beginner-friendly walkthrough of how to implement a basic malloc/free allocator in C</div><div class=post-meta><span title='2025-05-15 11:03:12 +0530 IST'>May 15, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Jay Gandhi</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#splitting>Splitting</a></li><li><a href=#address-ordered-free_list>Address ordered free_list</a></li><li><a href=#coalescing>Coalescing</a></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>In <a href=/posts/malloking-one>previous post</a>
, We implemented basic allocator which can be used in production enviornment for very faster memory allocation queries and we took the first step towards your first billion $$$. It was perfect but lets add more code to turn your billion dollars into millions. Let&rsquo;s change the strategy to improve fragmentation by adding more code (more code -> more bugs -> more loss). <a href=https://dub.gandhijay.com/no-code target=_blank rel=noopener>Hence no-code is the future.</a></p><p>There are two types of fragmentation, internal fragmentation, if 100 bytes are being asked to allocate, malloc returns block which size is 104. 4 bytes extra. Keep asking 100 bytes, 100 times, you will get 400 bytes extra in total but spread across the blocks in 4 bytes chunk. External fragmentation is if variable sized blocks are requested but there are none of the free blocks are in asked size. We&rsquo;ll go deeper in later..</p><h2 id=splitting>Splitting<a hidden class=anchor aria-hidden=true href=#splitting>#</a></h2><p>In previous post, we used to any block that would be larger than or equal size of the requested size. <code>size &lt;= currernt->size</code>. Now, We&rsquo;ll check that if block can be split into two blocks. New blocks&rsquo; sizes will be <code>size</code> and <code>current->size - size</code>. To Split, block size should be larger than the usable size. Usable size is summation of block metadata (<code>sizeof Block</code>) and minimum block size (<code>8</code>). Therefore block should only be splited if its size is greater than (or equal to) summation of requested size, block metadata and minimum block size. If leftover space after splitting is less than the block metadata + minimum block size then its not worth splitting, it would create an unsusable fragment.</p><p>Let&rsquo;s visualize it. We have block size of 100 bytes.</p><pre tabindex=0><code>+------------------------------+
|         Block Header         |  &lt;-- current (size = 100)
+------------------------------+
|                              |
|         Free Memory          |
|      (size = 100 bytes)      |
|                              |
+------------------------------+
</code></pre><p>Now, requested size is 40 bytes, so we need minimum <code>40 + Block Size (16) + Minimum split size (8) = 64 bytes</code> of the block for able to split without unusable fragment.</p><pre tabindex=0><code>+------------------------------+------------------------------+
|       Block Header A         |       Block Header B         |
+------------------------------+------------------------------+
|  Allocated to user (40 B)    |  Remaining free (44 B)       |
|                              |                              |
+------------------------------+------------------------------+

Block A total size: 40 (user) + 16 (header) = 56
Block B total size: 44 (free) = 44 ≥ MIN_SPLIT_SIZE
</code></pre><p>If block size would have been 50, it&rsquo;s no use to split as it would create 10B of unusable fragment.</p><p>Post split, new block should be added to the free list.</p><p>In code, we need to make changes as below in <code>malloc</code>,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define MINIMUM_SPLIT_SIZE 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>size_t</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Block <span style=color:#f92672>*</span>prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    Block <span style=color:#f92672>*</span>current <span style=color:#f92672>=</span> free_list;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    size <span style=color:#f92672>=</span> (size <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span><span style=color:#ae81ff>7</span>; <span style=color:#75715e>// Align to 8 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Search free_list only (not all blocks)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (current)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (current<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>&gt;=</span> size)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Check eligibilty of splitting.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (current<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>&gt;=</span> (size <span style=color:#f92672>+</span> BLOCK_SIZE <span style=color:#f92672>+</span> MINIMUM_SPLIT_SIZE))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Current block size would be reduced to requested size.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// new_block will be splited free block
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                Block <span style=color:#f92672>*</span>new_block <span style=color:#f92672>=</span> (Block <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)current <span style=color:#f92672>+</span> BLOCK_SIZE <span style=color:#f92672>+</span> size);
</span></span><span style=display:flex><span>                new_block<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>-</span> size <span style=color:#f92672>-</span> BLOCK_SIZE;
</span></span><span style=display:flex><span>                new_block<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                current<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> size;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (prev)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> new_block;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    free_list <span style=color:#f92672>=</span> new_block;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span>  {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Remove from free list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> (prev)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    prev<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    free_list <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)(current <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        prev <span style=color:#f92672>=</span> current;
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=address-ordered-free_list>Address ordered free_list<a hidden class=anchor aria-hidden=true href=#address-ordered-free_list>#</a></h2><p>As we are splitting the blocks, we need to coalesce the block as well to create a big block that can be splitted if required or satisfy the request of the similar size. From previous post, calling <code>free</code> is adding the freed block to the <code>free_list</code>&rsquo;s head as shown below,</p><pre tabindex=0><code>              +---------+     +---------+     +---------+     +---------+
free_list --&gt; | Block A | --&gt; | Block D | --&gt; | Block B | --&gt; | Block C | --&gt; NULL
              +---------+     +---------+     +---------+     +---------+
</code></pre><p>From random list, it will be additional effort to sort the list based on their addresses and then run coalesce logic. We can improve <code>free</code> to add free block in address order (sorted by memory address) so we can coalesce the consucutive block into one free block.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>free</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ptr)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;     <span style=color:#75715e>// Silently return, not failing not. It should fail.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    Block <span style=color:#f92672>*</span>block <span style=color:#f92672>=</span> (Block <span style=color:#f92672>*</span>)ptr <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;    <span style=color:#75715e>// ptr points to payload not the Block Metadata.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Insert at correct position in adddress order for coalescing.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>free_list <span style=color:#f92672>||</span> block <span style=color:#f92672>&lt;</span> free_list)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Free list is either empty or block is located
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// earlier in the memory than current head of free_list.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        block<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> free_list;
</span></span><span style=display:flex><span>        free_list <span style=color:#f92672>=</span> block;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Block <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> free_list;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (current<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>&amp;&amp;</span> current<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>&lt;</span> block)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        block<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        current<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> block;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Call Coalescing logic?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>coalescing_free_list</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>free_list</code> will remain sorted by memory address.</p><h2 id=coalescing>Coalescing<a hidden class=anchor aria-hidden=true href=#coalescing>#</a></h2><p>There&rsquo;s an option to call coalescing logic after the block is placed at its address ordered place. Coalescing everytime there&rsquo;s new free block on the list seems overly aggressive as same block might colesced and splitted repeatedly and not coalescing everytime we might end up not using the free block avaialble despite the availibility. In Glibc, there are multiple lists called bins. Bins categorize free memory chunks by size and optimize their reuse. There are fastbins, smallbins and largebins. Whether coalescing occurs immediately or is deferred depends on which bin the chunk is placed in.</p><p>Fastbins is for the smaller allocation and lazily coalesced where smallbins and largebins are for medium to large allocations and immediately coalesced on free.</p><p>For simplicity, we&rsquo;ll do coalescing each time we free the block.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>coalescing_free_list</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Block <span style=color:#f92672>*</span>curr <span style=color:#f92672>=</span> free_list;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (current <span style=color:#f92672>&amp;&amp;</span> current<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Char *, it moves N bytes instead of sizeof Block. Raw memory layout math!!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This byte address right after the current block ends which is where next adjacent block would begin.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      +------------------+-----------------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      | Block Metadata   |    Usable memory (size B)   |
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      +------------------+-----------------------------+
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      ^ current          ^ current + BLOCK_SIZE        ^ curr_end
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>curr_end <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)current <span style=color:#f92672>+</span> BLOCK_SIZE <span style=color:#f92672>+</span> current<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (curr_end <span style=color:#f92672>==</span> curr<span style=color:#f92672>-&gt;</span>next)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Adjacent: Let&#39;s merge
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            current<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>size <span style=color:#f92672>+</span> BLOCK_SIZE <span style=color:#f92672>+</span> current<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>size;
</span></span><span style=display:flex><span>            current<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            current <span style=color:#f92672>=</span> current<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s the basics of how basic memory allocator works.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.gandhijay.com/tags/malloc/>Malloc</a></li><li><a href=https://www.gandhijay.com/tags/memory/>Memory</a></li><li><a href=https://www.gandhijay.com/tags/free/>Free</a></li><li><a href=https://www.gandhijay.com/tags/brk/>Brk</a></li><li><a href=https://www.gandhijay.com/tags/sbrk/>Sbrk</a></li><li><a href=https://www.gandhijay.com/tags/c/>C</a></li><li><a href=https://www.gandhijay.com/tags/memory-management/>Memory Management</a></li><li><a href=https://www.gandhijay.com/tags/systems-programming/>Systems Programming</a></li></ul><nav class=paginav><a class=next href=https://www.gandhijay.com/posts/malloking-one/><span class=title>Next »</span><br><span>Building a Simple Memory Allocator Using sbrk in C (Malloking Pt. 1)</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.gandhijay.com/>Jay Gandhi</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>